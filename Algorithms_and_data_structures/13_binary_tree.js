// класс бинарного дерева поиска

// Бинарное дерево это структура данных где каждый узел так же является деревом тоесть струтктурой рекрсивно
// сновная суть в том что у каждго узла может быть только 2 потомка добовляются эти узлы тоже особым способом
// если доболяемое в дерево значение меньше по значению чем текущий угол то значение уходит в левое поддерево если больше уходит в правое
// сравнение происходит с каждым узлом и так полечается что правая часть поддерева выстраивается  бльшими значениями а левая с меньшими
// и это дерево называется бинарным деревом поиска поскольку аналогично бинарному алгоритму поиска сдесь можно находить данные за
// логорифмическое время


class BinaryTree {
    constructor() {
        this.root = null // корневой элимент
    }

    // функция каторая будет добовлять элименты в дерево
    add(value) {
        if (!this.root) { // если корневой элимент не существует тогда инициализируем его
            this.root = new TreeNode(value)
        } else { // если в дереве уже что то есть 
            let node = this.root // создаем переменную node в каторую помещаем корневой элимент
            let newNode = new TreeNode(value) // создаем новую ноду каторую будем добавлять в дерево
            // в цикле будем крутиться до тех пор пока эта нода не равно пустому значению
            while (node) {
                if (value > node.value) { // если значение каторое приняли параметром в функцию больше чем значение текущей ноды 
                                          // то уходим в правое поддерево в обратном случае уходим в левое поддерево
                    if (!node.right) {    // так же в условии проверяем если правого поддерева нет остановим цикл
                        break
                    }
                    node = node.right    // если првое поддерево есть присваеваем его текущей ноде
                } else {
                    if (!node.left) { 
                        break
                    }
                    node = node.left     // если значение меньше присваиваем левое поддерево
                }
            }
            // за счет такой структуры дерево получается отсортированым
            // таким образом после цикла получаем ноду каторая находится в самом низу дерева
            if (value > node.value) { // делаем проверку значения с этой ноды если это значение больше 
                node.right = newNode  // то теперь right будет ссылаться на новую ноду
            } else {                  // в обратном случае ссылаемся на левую ноду
                node.left = newNode
            }
        }
    }

    // сделаем функцию что бы это дерев визуализировать в консоль
    print(root = this.root) { // это будет рекурсивная функция параметром должна принимать какой то узел пдефолту корневой
        if (!root) {  // условие выхода из реркурсии
            return true
        }
        console.log(root.value) // выводим в логи значение текущего узла
        this.print(root.left)   // вызывае эту функцию для левого поддерева
        this.print(root.right)  // и для правого поддерева
        // тоесть сначало выведем в логи корневой элимент зате все элименты с левого поддерева затем с правого
    }
}

// класс для конкретно отдельного взятого узла в классе BinaryTree
class TreeNode {
    constructor(value) {
        this.value = value // значение каторое этот узел будет хранить
        // 2 ссылки на элименты каторые находятся в левой части дерева и в правой
        this.left = null
        this.right = null
    }
}

const tree = new BinaryTree
tree.add(5)
tree.add(2)
tree.add(6)
tree.add(2)
tree.add(1)  // сначало вывелись значения меньше чем 5 затем больше чем 5 - 6
tree.print()
// сортировка хоара быстра сортировка этот алгоритм работает за 0(n*log2n*n)
// один из самых эффективных алгоритмов сортировки
// принцип рабты разделяй и властвуй
// массив делится на подмассивы и каждый раз рекурсивно
// выбирается опорный элимент можно случайный но чаще всего берется ценральный
// пробегаеся по массиву и все элименты каторые меньше чем опорный добвляем в 1 масив каторые больше дбовляем в 2 массив
// после получается 2 массива с меньшими числами и с большими чем опорный элимент
// для каждого из этих массивов выполняется точно такая же опреация
// в каждои из подмассивов выбирается опорный элимент происходит сортировка
// и так делается до тех пор пока длина массива не станет равна 1 именно это усовие будет базовым условиемй выхода из рекурсии
// после всех операций отсортироаные подмассивы склеиваются в 1 бльшой
const arr = [12,3,2,5,6,8,1,9,4,2,1,2,9,6,4,1,7,-1,-5,23,6,2,35,6,3,32]
let count = 0

function quichSort(array) {
    if (array.length <= 1) { // базовый случай при катором рекрсия заканчивается если длина массива <= 1
        return array
    }
    let pivotIndex = Math.floor(array.length / 2) // индекс опорного элимента центральный из массива 
    let pivot = array[pivotIndex]                 // получаем сам опорный элимент
    let less = []                                 // массив в каторый будем сохронять числа меньше чем опорный
    let greater = []                                 // массив в каторый будем сохронять числа больше чем опорный
    // сравниваем каждый элимент с опорным 
    for (let i = 0; i < array.length; i++) {
        count += 1
        // сравниваем индекс текущей итерации с индексом опроного элимента если они равны эту итерацию пропускаем continue
        if (i === pivotIndex) {
            continue
        }
        // если текущей элимент итерации меньше чем опорный элимент то добовляем его в массив less
        if (array[i] < pivot) {
            less.push(array[i])
        } else { // если текущей элимент итерации больше чем опорный элимент то добовляем его в массив greater
            greater.push(array[i])
        }
    }
    // таким образом получится 2 массива с числами каторые больше и меньше опорного элимента
    // возвращаем массив в каторый разварачиваем результат выполнения рекурсивно функции quichSort в каторую передаем уже меньший подмассив less
    // посередине вставляем сам опорный элимент pivot и далее разварачиваем результат выполнения quichSort с большим подмассивом greater
    // таким образом каждая из этих подфункций каторые будут выполняться рекурсивно будет возвращать развернутый исходный массив
    // функции будут вызываться разветвляясь как дерево дойдя до базового случая когда останется 1 элиимент в массиве 
    // и склеиваются по итогу в 1 большой массив

    return [...quichSort(less), pivot, ...quichSort(greater)]
}

console.log(quichSort(arr))
console.log('count = ', count)


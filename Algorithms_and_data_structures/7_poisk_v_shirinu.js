// Графы Поиск в ширину
// граф это некаторая обстрактная структура данных представляющая собой множество вершин и набор ребер тоесть соединений между парами вершин
// самый простой наглядный пример графа это карта на каторой есть города и города соеденены маршрутами
// маршруты в данном случае это ребра а города это вершины
// ребра бывают однонапрвленными и двунаправленными тоесть из точки А можно попасть в точку B и из B в А
// но в данном случае будем считать что ребра однанаправленные слева на право
// есть граф задача найти путь из точки А в точку В за минимальное количество шагов

// в коде представить граф можно таким способом
// создается объект поля каорого это вершины и каждое поле равняется массиву вершин к каторой есть путь

const graph = {}
graph.a = ['b', 'c']
graph.b = ['f']
graph.c = ['d', 'e']
graph.d = ['f']
graph.e = ['f']
graph.f = ['g']

const graph1 = {
    'a': ['b', 'c'],
    'b': ['f'],
    'c': ['d', 'e'],
    'd': ['f'],
    'e': ['f'],
    'f': ['g']
}

let count = 0

// в этом алгориме будет использоваться такая структура данных как очередь
// очередь это структура данных состоящая из каких то элиментов
// основной принцип в том что элименты всегда добовляются в конец структуры а извлекаются из ее начала 
// FIFO-FIRST IN FIRST OUT первый вошел первый вышел

// функция поиска в ширену
function breadthSearch(graph, start, end) { // параметрами принимает сам граф стартовую точку и конечную
    let queue = [] // создаем граф просто массив можно извлекать из начала и добавлять в конец
    queue.push(start) // сразу же в очередь добовляем стартовую вершину
    while (queue.length > 0) { // создаем цикл в катором будем крутиться пока в этой очереди есть хотя бы 1 элимент
        count += 1
        // из начала очереди достаем текующую вершину на 1 итерации это будет стартовая вершина
        const current = queue.shift() // shift это функция каторая извлекает первый элимент из массива
                                      // на 1 итерации это будет стартовая вершина
        // console.log(current)
        if (!graph[current]) { // если по ткущей вершине в графе ничего не находится то присвоим этой вершине пустой массив тоесть из эой вершины
            graph[current] = [] // никуда пути нету что бы в дальнейшем когда будут обрабатываться массивы програма не сломалась
        }
        // если в графе по текущей вершине массив содержит конечную точку то завершаем выполнение программы и возвращаем true
        // тоесть на этом этапе обошли весь граф и пришли к пунккту назначения
        if (graph[current].includes(end)) { // функция includes проверяет есть ли в массиве данный элимент
            return true
        } else { // если условие не отработало то добовдяем в очередь новые вершины
            queue = [...queue, ...graph[current]] // разварачиваем то чо уже находится в очереди ...queue и в конец разварачиваем массив
                                                  // каторый лежит в графе по текщей вершине
            console.log(queue)
        }
        // и этот цикл будет крутиться пока очередь не пустая
    }
    return false
}

console.log(breadthSearch(graph1, 'a', 'g'))
console.log('count = ', count)

// Поиск в ширину решает задачу поиска пуив графе существует ли такой путь и находит путь за минимальное колчество
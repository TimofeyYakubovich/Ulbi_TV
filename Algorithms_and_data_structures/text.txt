Алгоритмы и структуры данных на примере js

Алгоритмы
- Поиска
- Сортировки
- Рекурсивные
- Дейкстры для поиска
кратчайшего пути в графе
- Обхода деревьев
- Кеширования

Структуры
- массивы
- связный список
- очередь
- стэк
- сет
- мэп
-двоичное дерево
- n-арное дерево
- графы


алогоритм это набор последовательных действий каторые решают какую то задачу
впринципе любой фрагмент кода можно назвать алгоритмом

оценка сложности алгоритов 
очевидно что некаторые алгориты являются эффективниее чем другие
причем эффективность не всегда равно сокрости работы алгоритма поскольку в некаторых ситуациях более медленный алгоритм может оказаться на
определенной выборке данных более эффективным

сложность алгортма или же его скорость в теории алгоритмов описывается с помощью специальной аннотации О большое O(n)
O(n)
(n) - количество операций за каторые этот алгоритм приходит к финальному результату причем указывается всегда наихудшая ситуация

представить сложность алгоритма можно так же ввиде графика
основные примеры функций каторыми чаще всего описываются сложность того или иного алгоритма
0(Log2n)	0(n)	0(n*log2n)	0(n*n)	0(n!)
график каждой последующей функции растет все быстрее и быстрее это говорит о том что скорость работы алгоритма очень низкая
в случае последнего графика 0(n!) существуют задачи решение каторых настолько долгие что их впринципе невозможно решить на данный момент


сраним 2 простейших алгоритма но с разной сожностью

есть массив состоящий из 10 элиментов 
[7,6,1,4,0,2,3,5,8,5]
надо реализовать алгоритм каторый будет искать в этом массиве определенный элимент

один из таких алгоритмов называется линейный поиск
начинаем с первого элимента и последовательно каждый элимент сравниваем с тем каторый ищем
в лучшем случае найдем элимент за 1 операцию если он находится в списке первым
в худшем случае этот элимент найдем в самом конце списка пройдясь по каждому элименту списка
оценка сложности производится по худшему сценарию поэтому сложность данного алгоритма будет O(n) О большое от n где (n) - количество элиментов 
в массиве
тоесть для массива из 10 элиментов сделаем 10 операций для массива из 1 000 000 элиментов сделаем 1 000 000 операций


другой алгоритм бинарынй поиск
он работает в разы быстрее но изночально подразумевает то что массив отсортирован попорядку

предствим арфографически словарь что бы найи какое то слово мы не будем листать весь словарь мы откроем его посередине и посмтрим букву
поскольку знаем что слова в словоре отсортированы по алфовиту
если искомое слово начинается с буквы каторая идет ранише той каторую мы открыли то мы поделем левую часть слворя опять на 2 части и будем 
искать уже там 
но если скомое слово начинается с буквы каторая идет после той каторую мы открыли то будем рассматривать правую часть словоря
таким образом с каждым разом отссеваем половину слов в слваре

рассмотрим на примере массива
[1,2,3,4,5,6,7,8,9,10] ищем 7
делим массив попалам получам 5 
7 больше чем 5 да значит левую часть откидываем работаем с правой 
[6,7,8,9,10] делим попалам получам 8
7 меньше чем 8 откидываем правую часть 
[6,7,8] делим массив попалам и натыкаемся на 7

сложность такого алгоритма 0 (log2n)

линейный поиск работает за линейное время бинарный за логорифмическое
если считать 1 операцию за 1 мс то для 1 000 000 элиментов 
бинарный алгоритм отрабатывает за 32 мс линейный будет работать 11 дней
но бинарный работает только с отсортирваным списком
а сортировать массив что бы применить бинарный алгоритм не имеет смысла поскльку время сортировки гораздо больше чем время работы линейного поиска

поэтому важно понимать когда и где применять тот или иной алгоритм
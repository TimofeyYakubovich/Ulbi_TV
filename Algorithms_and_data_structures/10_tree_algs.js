// алгоритмы для обхода дерева

// Рекурсивный обход дерева n-размерности
// Итеративный обход дерева n-размерности

// деревья это рекурсивная структура данных где каждый узел является так же деревом 
// но для данного дерева каждый узел является поддеревом

// есть вот такое дерево надой обойти каждый узел и посчитать сумму значений каторый хронит каждый узел
// такой массив каторый хронит в себе узлы каждый узел является ребенком
// значение узла лежит в поле v его дети лежат в поле c
const tree = [
    {
        v: 5,
        c: [
            {
                v: 10,
                c: [
                    {
                        v: 11
                    }
                ]
            },
            {
                v: 7,
                c: [
                    {
                        v: 5,
                        c: [
                            {
                                v: 1
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        v: 5,
        c: [
            {
                v: 10
            },
            {
                v: 15
            }
        ]
    }
]

// обойти дерево можно 2 способами рекурсией и циклом

// Рекурсивный обход дерева n-размерности
const recursive = (tree) => {
    let sum = 0 // значение суммы
    tree.forEach(node => { // так как дерево является массивом узлов итерируемся по нему forEach
        sum += node.v // на каждой итерации к суме добовляем значение каторое хронится в конкретном узле
        if (!node.c) { // если узел не имеет потомков выходим из рекурсии возврощаем значение узла
            return node.v
        }
        // к сумме добовляем результат выполнения этой же функции но параметром передаем уже уонкретно детей каждого узла
        sum += recursive(node.c)
        // каждая вызваная функция будет сумироваться в одну пееменную 
    });
    return sum
}

// Итеративный обход дерева n-размерности

// тут будет использоваться структура данных стек он похож на очередь но по другому принципе
// элименты всегда добовляются в конец структуры и извлекаются так же из конца
// если в очереди мы добовляли в конец а извлекали из начала то в стек мы и добовляем и извлекаем с конца

const iteration = (tree) => {
    if (!tree.length) { // если дерево пустое то возврощаем 0
        return 0
    }
    let sum = 0 // значение суммы все хузлов
    let stack = [] // переменная stack просто массив будем использоавть как стек
    tree.forEach(node => stack.push(node)) // итерируемся по всем вершинам дерева и добовляем их в стек
    // в цикле будем крутиться до тех пор пока этот стек не пустой
    while (stack.length) {
        // когда работаем с рекурсией каждая вызваная функция внутри функции добовляется в стек вызывов это встроеная в движок js концепция
        // мы эту работу стека вызывов сейчас сэмитируем
        const node = stack.pop() // извлекаем узел каторый находится на вершине стека
        sum += node.v
        if (node.c) { // если у этого узла есть потомки тогда пробегаемся по нима в цикле 
            node.c.forEach(child => stack.push(child)) // и добовляем каждого ребенка в стек
                                                       // затем на одной из следующий итераций этот узел вытащится и добавится его дети
                                                       // тоже добавятся в стек
        }
    }
    return sum
}

console.log(recursive(tree))
console.log(iteration(tree))
// Алгоритм дейкстры для поиска кратчайшего пути
// ессли в поиске в ширину мы находим кратчайший путь передвигаясь по вершинам графа и не важно длительный этот путь или нет главное это количество
// пройденых участков
// то в алгоитме дейкстры учитывается и длина прйденого ребра так называемый вес
// на рисунке видно что предыдущий путь каторый мы искали поиском в ширину ABFG в данном случае оказывается не самым быстрым
// поскольку растояние от B до F 7 едениц и в данной ситуаци необхдимо использовать Алгоритм дейкстры что бы высчитать кратчайший путь

// логика работы алгоритма дейкстры
// за стартовую точку принимаем A за конечную G
// состовляется таблица в каторую на 1 этапе записываются те значения вершин в каторые можно попасть из стартовой точки
// все остальные вершины являются недостежимыми их помечаем знаком бесконечности
// на 2 этапе помечаем эти вершины как уже рассмотренные 
// на 3 этапе расматриваем вершины в каторые можем попасть из точек B и C и в таблицу записываем значение от точки A до точек каторые мы
// достигаем из вершин B и C помечаем эти точки как уже рассмотренные
// на 4 этапе достигаем точки G но происходит перерасчет мы находим путь до точки F каторый оказывается кароче и перезаписываем 
// значение в таблице с 9 на 4
// на 5 этапе находим самый оптимальный путь до точки G узнаем что из А в G може добраться за 5 условных единиц


// теперь каждой вершине графа соответствует не массив как в поиске в ширину а объект с растоянием между 2 вершин

const graph = {}
graph.a = {b: 2, c: 1}
graph.b = {f: 7}
graph.c = {d: 5, e: 2}
graph.d = {f: 2}
graph.e = {f: 1}
graph.f = {g: 1}
graph.g = {}

const graph1 = {
    'a': {b: 2, c:	1},
    'b': {f: 7},
    'c': {d: 5, e:	2},
    'd': {f: 2},
    'e': {f: 1},
    'f': {g: 1},
    'g': {}
}

function shortPath(graph, start, end) {
    const costs = {} // создаем объект та самая таблица где будем хронить кратчайшие пути
    const processed = [] // создаем массив в каторый будем добавлять те узлы каорые мы уже проверили
    let neighbors = {} // создаем объект в нем будем хранить соседние вершины расматриваемого узла
    // далее надо заполнить таблицу и заполнить те вершины в каторые мы можем добраться из стартовой точки значениями
    // а все остальные должны заполнить бесконечно большим числом
    // для этого у графа получаем спсок ключей все вершины и итерируемся по им
    Object.keys(graph).forEach(node => { // Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта
        if (node !== start) { // если текущий элимент итерации не равна стартовой то будем заполнять значения
            // так как граф это объект у каторого есть поля где каждое поле эта вершина и каждое поле так же является объектом
            // у каторого есть свои значения то это значение мы пытаемся получить у стартовой позиции и получить значение либо B либо C
            let value = graph[start][node]
            // затем эти значения добовляем в таблицу массив в каторой будут хранится значения кратчайших путей
            costs[node] = value || 100000000
        }
    })
    // console.log(costs) // { b: 2, c: 1, d: 100000000, e: 100000000, f: 100000000, g: 100000000 }

    // далее надо найти вершину в каторую на данный момент мы можем попасть из точки А и путь в каторую самый кароткий
    // для этого реализуем функцию findNodeLowesCost
    console.log('costs', costs)
    let node = findNodeLowestCost(costs, processed) // передаем в нее объект со стоимостью всех путей и массив с уже обработанными узлами
    // вызываем функцию findNodeLowesCost получаем объект с минимальной стоимостью
    // далее делаем цикл while в катором будем крутиться до тех пор пока это node не пустая тоесть пока не обойдем весь граф
    while (node) { 
        const cost = costs[node] // на каждой итерации получаем стоимость текущей вершины
        neighbors = graph[node]  // и те узлы в каорые мы можем попасть из текущей вершины мы присваиваем в объект для соседних вершин
                                 // для того что бы можно было по ним проитерироваться
        Object.keys(neighbors).forEach(neighbor => { // итерируемся по массиву 
            // высчитываем новую стоимость если до каковота узла можем добраться более коротким путем то в таблице это значение надо перезаписать
            let newCost = cost + neighbors[neighbor]
            if (newCost < costs[neighbor]) { // еслли эта новая стоимость меньше чем стоимость каторая лежит в таблице для этого узла
                costs[neighbor] = newCost   // о перезаписываем ее
            }
        })
        processed.push(node) // вершину каторую рассматривали на данной итерации добовляем в массив уже обработанных вершин
                             // что бы при поиске новой вершины с минимальной стоимостью эта вершина учитываться не будет
        node = findNodeLowestCost(costs, processed) // и ищем новую вершину
        // console.log('costs', costs)
    }
    return costs // оызвращаем объект каторый хронит самые кротчайшие пути
    
}


function findNodeLowestCost(costs, processed) {
    let lowestCost = 100000000 // минимальное значение поумолчанию делаем этим большим числом
    let lowestNode;            // нода каторю поитогу будем возвращать с минимальным значением
    // итерируемся по ключам объекта со стоимостью путей
    Object.keys(costs).forEach(node => {
        let cost = costs[node] // получаем стоимость текущей ноды по ключу из объекта costs
        // если эта стоимость меньше чем минимальная стоимость и вершина каторую мы рассматриваем на текущей итерации не находитися в 
        // массиве обработаных вершин то нашли новый объект у каторого путь кароче
        if (cost < lowestCost && !processed.includes(node)) {
            lowestCost = cost // соответственно перезаписываем минимальную стоимость на ту каторую нашли на этой итерации
            lowestNode = node // и заменяем ноду
        }
    })
    console.log('lowestNode', lowestNode) // lowestNode c
    return lowestNode // возвращаем вершину с минимальной стоимостью
}

console.log(shortPath(graph, 'a', 'g'))
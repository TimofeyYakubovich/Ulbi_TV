import React, {useState, useEffect} from 'react';
import { postAPI } from '../services/PostService';
import PostItem from './PostItem';

const PostContainer = () => {
    const [limit, setLimit] = useState(10)
    // оброщпемся к postAPI у него есть ряд полей но самое интересное это авосгенерированые хуки useFetchAllPostsQuery каторые генерируются
    // на основании тех эндпоинтов каторые мы описываем
    // то что возвращает этот хук сразу диструктуризируем нас интересует поле data это тот самый список постов
    // ошибки обрабатываются автоматически и индекация загрузки делается автоатичски
    // когда мы используе хук то если эти данные из запроса где то используются еще то лишний запрос выполняться не будет
    // RTK query эти данные закеширует и своевременно обноовиит если в этом будет необходимость это полезно если есть выподающие списки с данными
    // каторые подгружаются асинхронно и эти списки используются в приложении например повсеместно и что бы получить данные для этих списков
    // достаточно использовать хуки и быть уверенным что не будет лишних запросов
    // но если овзникнит ситуация когда данные надо перезаписать то есть функция refetch каторую можно вызывать на какое то событие
    // и в таком случае данные будут подгружаны заново 
    // если нажимаем refetch запрос отправляется сново но списки не перерисовываются так как получаем те же данные
    // так же есть возможность реализовать лонгпулинг когда в определенный промежуток времени мы получаем обновленные данные
    // например в чатах уведомлениях аналог вебсокетов каждый промежуток времени отправляется новый запрос
    const {data: posts, error, isLoading, refetch} = postAPI.useFetchAllPostsQuery(limit, {// 1 аргументом этот хук ожидает параметр каторый будет 
        // pollingInterval: 1000                          // как то использоваться в запросе у нас таких параметов нет поэтому осталяем пустую строку
    })  
                                                 

    useEffect(() => {
        // в useEffect через setTimeout будем изменять limit
        // setTimeout(() => {
        //     setLimit(3)
        // }, 2000)
    }, [])

    return (
        <div>
            <div className="post__list">
                <button onClick={() => refetch()}>refetch</button>
                {isLoading && <h1>Идет загрузка...</h1>}
                {error && <h1>Произошла ошибка...</h1>}
                {posts && posts.map(post => // posts && posts.map(post => если есть посты и они не undefined и не null то тогда итерируемся
                    <PostItem key={post.id} post={post}/>
                )}
            </div>
        </div>
    );
};

export default PostContainer;
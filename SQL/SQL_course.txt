Базы данных

есть 2 вида баз данных это SQL бд реляционные и NoSQL не реляционные

реляционные бд хронят строго структурированные данные в сгрупированных таблицах
структура этих таблиц задается на этапе проектирования приложения
в реляционных бд есть таблицы они имеют четкую структуру и как то связаны между собой

не реляционные бд 
один самых популярных видов это документоориентрированные они хронят инфорацию в виде иерархических структур данных JSON формат
данные в них представлены просто как объект
еще один не менее популярный вид таких бд это пары ключ значение по какому то ключу сохроняются данные и по этому ключу данные извлекаются

то что в реляционной бд может быть представленно в нескольких таблицах в NoSQL в виде одной сущности

SQL это системы управления бд MySQL или PostgreSQL
NoSQL это MongoDB или Redis

расмотрим реляционные бд

реляционная бд предстовляет из себя набор связанных между собой таблиц
существуют определенные нормы по каторым эти таблици длжны создаваться
эти правила называются нормальные формы
1 все значения должны быть простыми тоесть одно поле содержит только одно значение
2 каждая запись должна иметь уникальный идентификатор id каторый будет определять запись
на примере фамилии преподователей пышкиных может 5 или 6 вася петя для отличия записи в бд для разных пышкиных присваевается id

Связи между таблицами

Один ко многим one-to-many
один учитель может преподавать несколько предметов
в такм случае в таблице каторая является many указывается внешний ключ id на таблицу каторая является one

Связь один-к-одному one-to-one
в большенсте случаев для этого вида можно даже не создавать отельную таблицу но для лучшей симантики логику обычно разделяют
есть 2 таблицы 1 таблиа с данными о каком то человеке 2 таблиас паспортами
1 человек может иметь только 1 паспорт
в 1 таблице человек указывается ссылка внешний ключ id на таблицу с паспортом

Связь много-ко-многим many-to-many
есть 2 независимыет таблицы с учетилями и с учениками при эом каждый студент у нескольких учителей и каждый учитель может преподавать нескольким
стдентам
в таком случае создается отдельная таблица Учителя-ученики в каторой обозначается какой учитель преподает у какова студента и какой студента
учится у какова учителя


не будем испльзовать никакое приложение
будем использовать терминал cmd
переходим C:\Program Files\MySQL\MySQL Server 8.0\bin

C:\>cd "Program Files"
C:\Program Files>cd MySQL
C:\Program Files\MySQL>cd "MySQL Server 8.0"
C:\Program Files\MySQL\MySQL Server 8.0>cd bin
C:\Program Files\MySQL\MySQL Server 8.0\bin>mysql -u root -p

SHOW DATABASES;  что бы посмотреть созданные бд
__________________________________________________________________________________________________________

CREATE DATABASE sql_course;  CREATE DATABASE что бы создать бд и название бд
__________________________________________________________________________________________________________

DROP DATABASE sql_course;  DROP DATABASE что бы удалить бд и название бд
__________________________________________________________________________________________________________

USE sql_course;  USE что бы использовать какую то конкретную бд и название бд
__________________________________________________________________________________________________________

show tables; что бы посмотреть таблицы каорые созданы в бд
__________________________________________________________________________________________________________

CREATE TABLE что бы создать таблицу затем название таблицы и в скобках указываются поля каторые будут в этой таблице (колонки)
1 поле в первую чередь создаем уникальный id каорый будет числового значения INT, AUTO_INCREMENTY будет автоинрементироваться каждая последующая 
запись будет иметь значение на 1 больше предыдущей, PRIMARY KEY уазываем что эо первичный ключ
2 поле фамилия учителя, будет строковое значение поэтому VARCHAR(255) и не может быть пустым NOT NULL

CREATE TABLE teacher(   
    id INT AUTO_INCREMENT PRIMARY KEY,
    surname VARCHAR(255) NOT NULL
);

Query OK, 0 rows affected (0.02 sec) таблица создана
show tables;
+----------------------+
| Tables_in_sql_course |
+----------------------+
| teacher              |
+----------------------+
1 row in set (0.00 sec)

show columns FROM teacher;    show columns FROM что бы посмотреть какие поля в таблице созданы и название таблицы teacher
+---------+--------------+------+-----+---------+----------------+
| Field   | Type         | Null | Key | Default | Extra          |
+---------+--------------+------+-----+---------+----------------+
| id      | int          | NO   | PRI | NULL    | auto_increment |
| surname | varchar(255) | NO   |     | NULL    |                |
+---------+--------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
__________________________________________________________________________________________________________

создадим 2 таблицу для уроков
2 поле название предмета
3 поле teacher_id так как тип свзяи между этими таблицами 1 ко многим делаем ссылку на таблицу с учетелями 
и уазываем что эо внешний ключ для этого пишем FOREIGN KEY (teacher_id) и уазываем ссылку на таблицу с каторой 
этот ключ будет свзывать references teacher(id)

тоесть teacher_id из таблицы lesson равен id из таблицы teacher

CREATE TABLE lesson(   
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    teacher_id INT NOT NULL,
    FOREIGN KEY (teacher_id) references teacher(id)
);

mysql> show columns FROM lesson;
+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| id         | int          | NO   | PRI | NULL    | auto_increment |
| name       | varchar(255) | NO   |     | NULL    |                |
| teacher_id | int          | NO   | MUL | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
__________________________________________________________________________________________________________

наполним таблицы данными
INSERT INTO что бы вставить новую запись в таблицу и название таблицы teacher затем в скобках поля каторые надо вставить (surname),
после values и значение через , в том же прядке в катором мы хотим их добовдядть в таблицу
id будет задаваться автоматически так как ему указали auto_increment

INSERT INTO teacher (surname) values ("Иванов");
Query OK, 1 row affected (0.01 sec)
INSERT INTO teacher (surname) values ("Петров");
INSERT INTO teacher (surname) values ("Сидоров");
INSERT INTO teacher (surname) values ("Петров");
INSERT INTO teacher (surname) values ("Чижкин");
INSERT INTO teacher (surname) values ("Петров");
__________________________________________________________________________________________________________

запрос на получение данных SELECT после название полей каорые хотим получить FROM и название таблицы teacher
* значит все существующие поля в этой таблице

SELECT * FROM teacher;

+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+
6 rows in set (0.00 sec)

допустим получить только id из этой таблицы

SELECT id FROM teacher;

+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
+----+
6 rows in set (0.00 sec)

получить несколько полей можно их дублировать

SELECT id, surname, surname FROM teacher; 
+----+---------+---------+
| id | surname | surname |
+----+---------+---------+
|  1 | Иванов  | Иванов  |
|  2 | Петров  | Петров  |
|  3 | Сидоров | Сидоров |
|  4 | Петров  | Петров  |
|  5 | Чижкин  | Чижкин  |
|  6 | Петров  | Петров  |
+----+---------+---------+
6 rows in set (0.00 sec)

есь несколько учетелей с одинаковыми фамилиями но если из таблицы надо получить только уникальные значения 
для этого используется ключевое слово DISTINCT и поле из каторго мы хотим получить

SELECT DISTINCT surname FROM teacher;
+---------+
| surname |
+---------+
| Иванов  |
| Петров  |
| Сидоров |
| Чижкин  |
+---------+
4 rows in set (0.00 sec)
__________________________________________________________________________________________________________

получить данные по какому то условию
для этого делаем обычный SELECT запрос поле него указываем ключевое слово WHERE после само условие

SELECT * FROM teacher WHERE id = 1;
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
+----+---------+
1 row in set (0.00 sec)

SELECT * FROM teacher WHERE id = 3;
+----+---------+
| id | surname |
+----+---------+
|  3 | Сидоров |
+----+---------+
1 row in set (0.00 sec)

SELECT * FROM teacher WHERE id > 3;
+----+---------+
| id | surname |
+----+---------+
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+
3 rows in set (0.00 sec)

SELECT * FROM teacher WHERE surname = "Петров";
+----+---------+
| id | surname |
+----+---------+
|  2 | Петров  |
|  4 | Петров  |
|  6 | Петров  |
+----+---------+
3 rows in set (0.00 sec)

так же можно указывать ограничения с помощью ключевого слова LIMIT

SELECT * FROM teacher WHERE surname = "Петров" LIMIT 2;
+----+---------+
| id | surname |
+----+---------+
|  2 | Петров  |
|  4 | Петров  |
+----+---------+
2 rows in set (0.00 sec)

SELECT * FROM teacher LIMIT 5;
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
|  5 | Чижкин  |
+----+---------+
5 rows in set (0.00 sec)
__________________________________________________________________________________________________________

можно переименовывать колонки id и surname

SELECT id AS 'Идентификатор', surname AS 'Фамилия' FROM teacher;
+---------------+---------+
| Идентификатор | Фамилия |
+---------------+---------+
|             1 | Иванов  |
|             2 | Петров  |
|             3 | Сидоров |
|             4 | Петров  |
|             5 | Чижкин  |
|             6 | Петров  |
+---------------+---------+
6 rows in set (0.00 sec)
__________________________________________________________________________________________________________

сортировка данных 
чтобы отсортировать выборку испльзуется ключевое слово ORDER BY затем указывается поле по каторому надо отсортировать данные

SELECT * FROM teacher ORDER BY surname;
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  4 | Петров  |
|  6 | Петров  |
|  3 | Сидоров |
|  5 | Чижкин  |
+----+---------+
6 rows in set (0.02 sec)

SELECT * FROM teacher ORDER BY id;
+----+---------+
| id | surname |
+----+---------+
|  1 | Иванов  |
|  2 | Петров  |
|  3 | Сидоров |
|  4 | Петров  |
|  5 | Чижкин  |
|  6 | Петров  |
+----+---------+
6 rows in set (0.00 sec)

что бы данные пришли в обратном порядке испльзуется ключевое слов DESC

SELECT * FROM teacher ORDER BY id DESC;
+----+---------+
| id | surname |
+----+---------+
|  6 | Петров  |
|  5 | Чижкин  |
|  4 | Петров  |
|  3 | Сидоров |
|  2 | Петров  |
|  1 | Иванов  |
+----+---------+
6 rows in set (0.00 sec)
__________________________________________________________________________________________________________

ALTER TABLE что бы добавить еще одно поле в сущесвтующую таблицу затем ADD и нзвание колонки потом ее тип и ограничения INT

ALTER TABLE teacher ADD age INT;
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0

show columns FROM teacher;
+---------+--------------+------+-----+---------+----------------+
| Field   | Type         | Null | Key | Default | Extra          |
+---------+--------------+------+-----+---------+----------------+
| id      | int          | NO   | PRI | NULL    | auto_increment |
| surname | varchar(255) | NO   |     | NULL    |                |
| age     | int          | YES  |     | NULL    |                |
+---------+--------------+------+-----+---------+----------------+
3 rows in set (0.01 sec)

SELECT * FROM teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  | NULL |
|  2 | Петров  | NULL |
|  3 | Сидоров | NULL |
|  4 | Петров  | NULL |
|  5 | Чижкин  | NULL |
|  6 | Петров  | NULL |
+----+---------+------+
6 rows in set (0.00 sec)
__________________________________________________________________________________________________________

UPDATE для обнавления данных в табблице затем название таблицы псоле SET потом поле каторое нао изменить и какое то условие его id
если не указывать условие будут изменены все сущесвтующую записи в таблице

UPDATE teacher SET age = 20 WHERE id=1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   20 |
|  2 | Петров  | NULL |
|  3 | Сидоров | NULL |
|  4 | Петров  | NULL |
|  5 | Чижкин  | NULL |
|  6 | Петров  | NULL |
+----+---------+------+
6 rows in set (0.00 sec)

если не указывать условие UPDATE teacher SET age = 25; будут изменены все сущесвтующую записи в таблице
mysql> SELECT * FROM teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   25 |
|  3 | Сидоров |   25 |
|  4 | Петров  |   25 |
|  5 | Чижкин  |   25 |
|  6 | Петров  |   25 |
+----+---------+------+
6 rows in set (0.00 sec)

UPDATE teacher SET age = 30 WHERE id=2;
UPDATE teacher SET age = 35 WHERE id=3;
UPDATE teacher SET age = 40 WHERE id=4;
UPDATE teacher SET age = 45 WHERE id=5;
UPDATE teacher SET age = 50 WHERE id=6;
__________________________________________________________________________________________________________

при задании условия SELECT * FROM teacher WHERE surname LIKE "%ов"; можно указать ключевое слово LIKE после каторго задется шаблон поиска
% означает что вместо него может быть любое количество символов

SELECT * FROM teacher WHERE surname LIKE "%ов";
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  6 | Петров  |   50 |
+----+---------+------+
5 rows in set (0.00 sec) вернулись все учетеля фамилия каторых заканчивается на ов

SELECT * FROM teacher WHERE surname LIKE "%ин";
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  5 | Чижкин  |   45 |
+----+---------+------+
1 row in set (0.00 sec)

SELECT * FROM teacher WHERE surname LIKE "п%ов";
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  2 | Петров  |   30 |
|  4 | Петров  |   40 |
|  6 | Петров  |   50 |
+----+---------+------+
3 rows in set (0.00 sec)
__________________________________________________________________________________________________________

логические операторы

после WHERE указываем 1 условие пишем AND и 2 условие плучим только те записи для каторых подходят и 1 и 2 условие
SELECT * FROM teacher WHERE id > 3 AND age < 45;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  4 | Петров  |   40 |
+----+---------+------+
1 row in set (0.00 sec)

SELECT * FROM teacher WHERE id > 3 AND age < 46;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+
2 rows in set (0.00 sec)

ключевое слово OR под выборку попадут все записи каторым подходит или 1 условие и 2 

SELECT * FROM teacher WHERE id > 4 OR age > 31;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
|  6 | Петров  |   50 |
+----+---------+------+
4 rows in set (0.00 sec)

ключевое слово NOT отрицание какого либо условия

SELECT * FROM teacher WHERE NOT id = 2;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
|  6 | Петров  |   50 |
+----+---------+------+
5 rows in set (0.00 sec)
__________________________________________________________________________________________________________

BETWEEN для того что бы получить выборку между какими то 2 значениями

SELECT * FROM teacher WHERE age BETWEEN 35 AND 45;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+
3 rows in set (0.00 sec)

__________________________________________________________________________________________________________

DELETE что бы удалять данные из таблици если указывать без условия удаляться все данные 

DELETE FROM teacher WHERE id = 6;

SELECT * FROM teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+
5 rows in set (0.00 sec)
__________________________________________________________________________________________________________

Объединение таблиц

mysql> show columns FROM lesson;
+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| id         | int          | NO   | PRI | NULL    | auto_increment |
| name       | varchar(255) | NO   |     | NULL    |                |
| teacher_id | int          | NO   | MUL | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)

добавим несколько записей в таблицу lesson указываем калонки каторые хотим добавить (name. teacher_id) затем значения teacher_id это ссылка на сущесвтующего учителя 
с таблицы teacher Математика будет преподавать учитель с id = 1 и информатику тоже учитель с id = 1

INSERT INTO lesson (name, teacher_id) VALUES ("Математика", 1), ("Информатика", 1), ("Русский", 2), ("Физика", 3);
Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0

SELECT * FROM lesson;
+----+-------------+------------+
| id | name        | teacher_id |
+----+-------------+------------+
|  1 | Математика  |          1 |
|  2 | Информатика |          1 |
|  3 | Русский     |          2 |
|  4 | Физика      |          3 |
+----+-------------+------------+
4 rows in set (0.00 sec)

SELECT * FROM teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
+----+---------+------+
5 rows in set (0.00 sec)

Есть 2 вида объединений внутреннее INNER JOIN и внешнее OUTER JOIN

если мы делае запрос с использованием INNER JOIN или просто JOIN эти записи равносильные то в исходную таблицу попадут только те записи где для каждого учителя есть урок
те учителя каторые уроки не видут в исходную таблицу не попадают

внешнее OUTER JOIN бывают левосторонние и правосторонние Объединение
в случае левостороннего LEFT OUTER JOIN в исходную таблицу попадают все учителя причем неважно видут они уроки или нет
в случае правостороннего наоброт попадают в выборку все уроки причем не важно есть учитель каторый видет этот урок или нет

есть еще FULLJOIN в выборку попадают обсалютно все значения

внутреннее объединение
SELECT затем указываем колонки каорые попадут в исходную таблицу teacher.surname, lesson.name затем FROM уазываем левую таблицу с каторой будет происходить объединение teacher
пишем INNER JOIN и таблицу правую с каторой будет происходить объединение lesson затем ключевое слово ON 
и столбцы по каторым будет происходить объединение teacher.id = lesson.teacher_id

SELECT teacher.surname, lesson.name FROM teacher INNER JOIN lesson ON teacher.id = lesson.teacher_id;
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Сидоров | Физика      |
+---------+-------------+
4 rows in set (0.00 sec) 4 записи так как некаорые учетиял уроки не видут


левостороннее внешнее объединение
SELECT teacher.surname, lesson.name FROM teacher LEFT OUTER JOIN lesson ON teacher.id = lesson.teacher_id;
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Сидоров | Физика      |
| Петров  | NULL        |
| Чижкин  | NULL        |
+---------+-------------+
6 rows in set (0.00 sec)  получили всех преподавателей даже тех каторые не видут уроки


правостороннее внешнее объединение
SELECT teacher.surname, lesson.name FROM teacher RIGHT OUTER JOIN lesson ON teacher.id = lesson.teacher_id;
+---------+-------------+
| surname | name        |
+---------+-------------+
| Иванов  | Математика  |
| Иванов  | Информатика |
| Петров  | Русский     |
| Сидоров | Физика      |
+---------+-------------+
4 rows in set (0.00 sec)  так как нет предметов каторые не вел бы какой то учитель


так же можно объеденить таблицы вертикально UNION
запрос ля 1 таблицы UNION и запрос для второй таблицы их может быть бесконечно много

SELECT * FROM teacher UNION SELECT * FROM lesson;
+----+-------------+------+
| id | surname     | age  |
+----+-------------+------+
|  1 | Иванов      |   25 |
|  2 | Петров      |   30 |
|  3 | Сидоров     |   35 |
|  4 | Петров      |   40 |
|  5 | Чижкин      |   45 |
|  1 | Математика  |    1 |
|  2 | Информатика |    1 |
|  3 | Русский     |    2 |
|  4 | Физика      |    3 |
+----+-------------+------+
9 rows in set (0.00 sec)  но есть проблема с именованеим колонок
__________________________________________________________________________________________________________

функции для вычеслений

SELECT название функции в () поле над каторым будет работать функция 
AVG() возвращает средний возраст учителей из таблицы

SELECT AVG(age) FROM teacher;
+----------+
| AVG(age) |
+----------+
|  35.0000 |
+----------+
1 row in set (0.00 sec)

функции максимального MAX и минимального MIN значения
SELECT MAX(age), MIN(age) FROM teacher;
+----------+----------+
| MAX(age) | MIN(age) |
+----------+----------+
|       45 |       25 |
+----------+----------+
1 row in set (0.00 sec)


функция SUM сумма всех значений каторые попадают в выборку

SELECT SUM(age) FROM teacher;
+----------+
| SUM(age) |
+----------+
|      175 |
+----------+
1 row in set (0.00 sec)
__________________________________________________________________________________________________________

так же результаты можно групировать

добавим еще 2 учителей в таблицу с таким же возрастом с каторым учителя уже есть

INSERT INTO teacher (surname, age) VALUES ("Пупкин", 25), ("Шишкин", 25);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

SELECT * FROM teacher;
+----+---------+------+
| id | surname | age  |
+----+---------+------+
|  1 | Иванов  |   25 |
|  2 | Петров  |   30 |
|  3 | Сидоров |   35 |
|  4 | Петров  |   40 |
|  5 | Чижкин  |   45 |
|  7 | Пупкин  |   25 |
|  8 | Шишкин  |   25 |
+----+---------+------+
7 rows in set (0.00 sec)

сгрупируем

запрос SELECT далее поле age и колчество человек с этим возрастом COUNT(age) из какой таблицы FROM teacher и ключевое слово GROUP BY age
COUNT подсчитывает количество человек

SELECT age, COUNT(age) FROM teacher GROUP BY age;
+------+------------+
| age  | COUNT(age) |
+------+------------+
|   25 |          3 |
|   30 |          1 |
|   35 |          1 |
|   40 |          1 |
|   45 |          1 |
+------+------------+
5 rows in set (0.00 sec) 3 человека 25 летних все остальные по 1

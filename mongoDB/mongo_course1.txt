типы связей

тип связи один ко многим
тоесть в данном случае для какова нибудь пользователя добавим посты

почему один ко многим один пользователь может иметь несколько постов
эти несколько постов могут принадлежать только одному пользователю

обновляем пользователя vasya
2 параметром передаем объект у каорого указываем поле $set и в него передаем критерии каторые
надо заменить туда передаем posts массив из нескольких объектов
db.users.update(
    {fillname: "ulbiTV"},
    {
        $set: {
            posts: [
                {title: 'javascript', text: 'js top'},
                {title: 'mongo', text: 'mongo top'}
            ]
        }
    }
) 1 запись была обновлена

{
  _id: ObjectId("64386ea1863741c2e194774b"),
  age: 42,
  fillname: 'ulbiTV',
  posts: [
    {
      title: 'javascript',
      text: 'js top'
    },
    {
      title: 'mongo',
      text: 'mongo top'
    }
  ]
}
_________________________________________________________________________________________

в функцию findOne передадим

db.users.findOne(
    {fillname: 'ulbiTV'},
    {posts:1}
)
в таком случае получим только посты самого пользователя

{
  _id: ObjectId("64386ea1863741c2e194774b"),
  posts: [
    {
      title: 'javascript',
      text: 'js top'
    },
    {
      title: 'mongo',
      text: 'mongo top'
    }
  ]
}
_________________________________________________________________________________________

что бы найти пользователя у аторого есть конкретный пост используется оператор $elemMatch
и в него указываем критерий поста по каторому надо исать title: "javascript"

db.users.findOne(
    {
        posts: {
            $elemMatch: {
                title: "javascript"
            }
        }
    }
)
плучаем всего пользователя
{
  _id: ObjectId("64386ea1863741c2e194774b"),
  age: 42,
  fillname: 'ulbiTV',
  posts: [
    {
      title: 'javascript',
      text: 'js top'
    },
    {
      title: 'mongo',
      text: 'mongo top'
    }
  ]
}
_________________________________________________________________________________________

есть оператор $exists с помощью каторого можно найти пользователя у каторого есть нужное поле

db.users.find({posts: {$exists: true}})

{
  _id: ObjectId("64386ea1863741c2e194774b"),
  age: 42,
  fillname: 'ulbiTV',
  posts: [
    {
      title: 'javascript',
      text: 'js top'
    },
    {
      title: 'mongo',
      text: 'mongo top'
    }
  ]
}

оптимизация связей 
допустим есть массив address в атором лежат какие то объкты
похорошему эти объекты выносить в отдельную колекцию
а в массив адресов address_ids добовдять id этих объектов 

тоесть адреса id в одной а сущность пользователя в другой
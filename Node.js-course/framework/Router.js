// так как мы делаем что то типа фреймворка похоршему что бы он был переиспользуемым вынесем его в отдельную папку framework
// перенесем сюда class Router


// но таким образом через if else писать сервера невозможно обычно используют фреймворки по типу express и другие 
// сделаем свою реализацию по типу express с нормальной маршрутизацией 

// впервую очередь создадим класс Router реализуем конструктор и в конструкторе принициализируем объект endpoints
// у этого объекта будет вот такая структура:
// endpoints = {
//     '/users': {  как ключ будем добовлять адрес какова то эндпоинта как значение еще один объект 
//     'GET': handler1,   в катором как ключ будет метод GET POST DELETE а под значение будет какой то handler тоесть обработчик
//     'POST': hadler2,   тоесть функция каторя на этот эндпоинт должна отработать
//     'DELETE': handler3
//     }
// }


module.exports = class Router { // module.exports экспортруем class Router из этого файла
    constructor() {
        this.endpoints ={}
    }

    // дбавим в этот класс метод каторый будет принимать аргументы method поумолчанию "GET" path - путь до этого метода и сам hadler - какой то
    // колбек каторый будет по этому адресу отрабатывать
    request(method = "GET", path, handler) {
        // сначала надо убедиться что такова эндпоинта еще нет делаем проверку
        if (!this.endpoints[path]) { // получаем по ключу endpoints полю path
            this.endpoints[path] = {} // если по этому адресу ничего не добавлено то инициализируем его пустым объектом
        }
        // далее для удобства этот эндпоинт вынесем в отдельную переменную
        const endpoint = this.endpoints[path]; // что бы каждый раз из объекта его не получать

        // так как для каждого маршрута могут быть разные методы GET POST PUT DELETE надо в условии убедиться что по такому адресу такова 
        // метода не существует инче будет конфликт и надо пробросить ошибку
        if (endpoint[method]) {
            throw new Error(`[${method}] по адресу ${path} уже сущесвтует`) // выбрасываем ошибку
        }
        // если это условие не отработало 
        endpoint[method] = handler; // записываем в этот endpoint по ключу method handler колбек каторый будет по этому адресу отрабатывать
        // но просто записать етод недостаточно на соответствующий запрос надо генерировать соответствующее событие импортируем events
        // создаем объект из EventEmitter const emitter = new EventEmitter(); пока что глобально

        // создаем событие но по особому названию что бы потом в нужном месте можно было его сгенерироать и вызвать нужный handler
        // маска [path]:[method] это можно прописывать поразному это как пример
        
        // emitter.on(`[${path}]:[${method}]`, (req, res) => { // 2 аргументом колбек каорый на это событие будет вызываться принимает req, res
        //     handler(req, res) // и уже внутри колбека вызваем handler и в него передаем 2 стрима req, res
        // })  // по определенному пути создаем обработчик каторый должен принять от пользователя запрос и вернуть ему ответ
    }

    // что бы не указывать каждый раз в router.request('GET') меод запроса 
    // сделаем набор методов у роутера как в express это методы оболочки для вызыва функции request
    get(path, handler) {
        this.request('GET', path, handler)
    }
    post(path, handler) {
        this.request('POST', path, handler)
    }
    put(path, handler) {
        this.request('PUT', path, handler)
    }
    delete(path, handler) {
        this.request('DELETE', path, handler)
    }
}
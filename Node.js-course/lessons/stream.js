// stream !== Thread

// stream переводится как поток но не путать с тредами с потоками каторые расматривали в начале 
// потоки чтение с БД, запись файла на диск, обработка http запроса это треды (Thread) потоки выполнения

// в node.js есть 4 типа стримов

// Readable - чтение
// Writable - Запись
// Duplex - Для чтения и записи Readable + Writable
// Transform - Такой же как Duplex, но может изменить данные по мере чтения

// для чего нужны стримы? 
// допустим есть файл каторый состоит из кусочкев и весит 5гб если читать этот файл спомощью fs.readFile то прочитаем весь файл целиком и 
// это может занять длительное время если файл большой
// например этот файл надо куда то отправить он весит 5гб и пока он весь не прочитается мы его никуда не отправим

// надо отправлять этот файл покусочкам стримы для этого и предназначены
// файл читается покусочкам прочитали кусок сразу же его отправили прочитали 2 опять отправили
// поумолчанию размер 1 кусочка 64 кб

// считывать можно не только файлы это может быь передача чего то посети скачивание чего то посети все что можно передавать или скачивать 
// покусочкам и это необезательно файлы

const fs = require('fs');
const path = require('path');

// есть файл test.txt каторый весит 405 КБ

// fs.readFile(path.resolve(__dirname, 'test.txt'), (err, data) => {
//     if (err) {
//         throw err;
//     }
//     console.log(data)
// })

// запускаем код так как кодировку мы не указали вернулся буфер весом 415616 more bytes считали его целиком и за один раз


// как тоже саое можн осделаь с помощью стримов

// для того что бы получить стрим для чтения файлов в модуле fs есть метод fs.createReadStream он создает стрим для чтения

const stream = fs.createReadStream(path.resolve(__dirname, 'test.txt')) // передаем в него путь но колбек не передаем

// так же при создании стрима 2 аргументом можно указать некаорые опции например кодировку utf-8 что бы не получать буфер
// отключить автозакрытие и тд.

// стримы работают по принципу событий надо подписаться на определенное событие 
stream.on('data', (chunk) => { // первое событие самое важное 'data' позволяет считывать файл, 2 аргументом передаем колбек каторый принимает
    console.log(chunk)         // аргументом chunk тот кусочек файла каторый мы прочитали
})

// запускаем код получаем 6 кусочков по 65486 more bytes или 64 кб и 7 22400 more bytes
// тоесть прочтиали его 7 раз

// у стримов есть целый ряд событий открытие, закрытие можно ставить на паузу, продолжать чтение и тд.

stream.on('end', () => console.log('Закончили читать'))
stream.on('open', () => console.log('Начали читать'))

// запускаем код получаем Начали читать Закончили читать между ними процес чтения 
// на события можно подписыаться в любом порядке это сдесь не столь важно они работают асинхронно

// так же надо обрабатывать ошибки для этого необходимо подписаться на событие 'error' 
// если такую обработку не сделаь может упасть весь node.js процесс обработка ошибк важный процесс

stream.on('error', (e) => console.log(e))

// указываем путь к несуществующему файлу запускаем код получаем ошибку Error: ENOENT: no such file or directory, open


// fs.createWriteStream предназанчен для записи
const writeStream = fs.createWriteStream(path.resolve(__dirname, 'test2.txt')) // передаем путь к файлу в каторый надо что то записать
for (let i = 0; i < 20; i++) { // сделаем цикл и внутри цикла будем покусочкам записывать 
    writeStream.write(i + '\n') // у стрима writeStream вызываем метод write сделаем перенос строки после каждой записи '\n'
}

writeStream.end() // createWriteStream надо завершать вручную для этого вызывать функцию end()
// запускаем код появился файл test2.txt и в него записались 20 раз числа

// так же у createWriteStream есть другие меоды что бы его закрыть close() и destroy() они вызывают разные события и на эти события можно
// так же подписаться
// в зависимости от того как закрыли стрим вызыаются разные события и надо поразному их обрабатывать
// где то writeStream.on('error') где то writeStream.on('close')
// writeStream.close()
// writeStream.destroy()
// writeStream.on('error')


// при работе с http сервером для нас доступны 2 объекта req, res
// так вот эти 2 объекта являются стримами 
// req - Readable stream, 
// res - Writable stream
// у них есть те же самые методы write, end так же можно подписаться на те же самы события close end и тд.

const http = require('http');

http.createServer((req, res) => {
    // например надо отправить пользовотелю какой то файл для этого получаем Readable stream стрим createReadStream
    const stream = fs.createReadStream(path.relative(__dirname, 'test.txt')) // передаем путь к файлу

    // stream.on('data', chunk => res.write(chunk)) // после подписываемся на событие 'data' что бы считывать чанки по 64кб и как только 
    // этот чанк прочитан мы записываем его в респонс res.write(chunk) и таким образом отправляем этот кусочек пользователю по сети

    // stream.on('end', chunk => res.end()) // так же надо обработать ситуацию когда закончили читать файл и завершить сетевое подключение res.end()
    // может покозаться что все сделано праввильно но сетевое пдключение значительно медленее чем чтение файла 
    // и возникнет такая ситуация что файцл проситали соединение закончили но при этом ползователь еще всесь этот файл скачать не успел

    // для этого придумали метод pipe и в него надо передать Writable stream - res
    // таким образом достигается синхронизация между Readable и Writable стримами
    // Readable стрим не начинает читать новую порцию данных пока Writable стрим не закончил записывать предыдущюю
    // и конечно обработка ошибок
    stream.pipe(res)
})
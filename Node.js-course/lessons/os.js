// модуль os позволяет взаимодействовать с операционной системой
const os = require('os');
const cluster = require('cluster') // модуль cluster предназначен для того что бы однопоточному node.js приложению использовать все возможности
// многоядерных систем и запускать дочерние процессы начиная с 16 версии API кластера поменялось

console.log(os.platform()) // функция platform позволяет получить текушую операционную систему аналогично функции process.platform
// возвращает win32
console.log(os.arch()) // функция arch возвращает архитектуру процессора
console.log(os.cpus()) // функция cpus возвращает массив в катором каждый объект массива это описание ядра поцессора
console.log(os.cpus().length) // количество ядер в звисимости от количество ядер можно запускат разное количесво процессов node.js приложения

// const cpus = os.cpus();

// for (let i = 0; i < cpus.length - 2; i++) {  // в цикле пробегаемся по количеству ядер получаем соответствующее ядро запускаем процесс
//     const CPUcore = cpus[i];                 // и желательно оставить 1 и 2 ядра свободным для ОС
//     console.log('Запустить еще один node js процесс') 
// }

// console.log(process.pid); // получаем id процесса

// while (true) {

// }

if (cluster.isMaster) { // сделаем проверку является ли текущей процесс главным за это отвечает свойство isMaster
    // если процесс галвный мы должны запустить дочерние процессы
    for (let i = 0; i < os.cpus().length - 2; i++) { 
        cluster.fork() // сдесь для каждого ядра будем запускать процесс у кластера вызываем фунцию fork() запускает дочерний процесс
    }

    cluster.on('exit', (worker) => { // подписываемся на событие 'exit' точно так же как на событие нажатие кнопки или инпута
        console.log(`воркер с pid = ${worker.process.pid} умер`) // если вдруг процесс по какой то причине умер отработало событие 'exit'
        // в логи будем выводить воркер с таким то id умер 
        cluster.fork() // и сразу же запускаем новый процесс что бы всегда работало максимальное количество воркеров
        // что бы пользоваться максимальной эфективностью многоядерных систем
    })

} else { // else отработает в том случае когда будут запускаться дочерние процессы
    console.log(`воркер с pid = ${process.pid} запущен`)

    setInterval(() => {
        console.log(`воркер с pid = ${process.pid} еще работает`)
    }, 5000)
}

// в диспетчере задач висит 2 дочерних процесса node.js приложения
// воркер с pid = 13288 еще работает 
// воркер с pid = 9624 еще работает
// остановим процесс kill 9624 процесс может упасть по любой причине из за ошибки что то сломалось и такие ситуации надо продумывать и 
// обрабатывать
// можно подписываься на определенные события это делается с помощью EventEmitter

// убиваем один из процессов kill 5984 в консоле воркер с pid = 5984 умер и сразу же запусился воркер с pid = 12624 еще работает
// если по какой то причине надо процесс полностью остановить можно передавать вместе с worker коды сигналы и в зависимости от этих кодов 
// сигналов можно процесс полностью убивать или запусаь еще одни процесс чаще всего  вручную это не делается есть готовые библиотеки

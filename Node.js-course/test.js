// - что такое Npm node.js на каких концепциях построен node.js движек V8, libuv
// - асинхронная модель блокирующий неблокирующий ввод вывод, многопоточность, шаблон реактор, демультиплексор событий,
// событийноориентированную модель node.js, особенности Event loop 

// практическая часть стандартые модули
// - модуль process
// - path и URL
// работа file systems
// модуль по работе с операционной системой и модуль cluster для того что бы запускать несколько процессов одного приложения
// Event emitter. создавать генерироать события
// стримы 
// http сервер
// - сделаем небольшой фреймвор потипу express
const sum = 1 + 5;
console.log(sum);
console.log('Hello World');

// npm (Node Package Manager) — менеджер пакетов, входящий в состав Node.js содержит в себе огромное количество разный пакетов 
// включая express react vue nest.js и тд
// достаточно знать название пакета и иметь установленный npm на компьютере и можно любой из этих пакетов установить в проект
// например надо сделать сервис сайт рендеринг на express и react 
// устанавливаем npm install express react
// если надо удалить npm uninstall express
// для того что бы зависимости устанавливать надо проект принициализировать npm init и в корне проекта появится файлик package.json
// с зовисимостями проекта 
// поля dependencies и devDependencies
// утсановим express npm i express появился в поле dependencies
// для того что бы становить зависимость именно для разработки пишем --save-dev в момент продакшена они будут выкинуты из финальной кофинурации
// npm i --save-dev nodemon  появился в поле devDependencies
// папка node_modules в нее устанавливаются все зависимости проекта


// что предстовляет из себя node.js на чем он построен как из разработки браузерных приложений на JS перешли к полнофункциональной разработке на JS
// как node.js позволяет делать серверные приложения

// node это не язые програмирования а програмная платформа с помощью специальных инструментов node превращает JS в машинный код
// изначально JS это язык разработки браузерных приложений и некаторая функциональность там очень ограничена
// например взаимодействие с опреционной системой мы не может работа с файловой системой крайне ограничена
// node.js добовляет возможность для JS взаимодействовать с устройствами ввода вывода через свой специальный API написаный на C++

// какие приемущеста дает node.js?
// - простота человек катоырй знает JS может в кратчайшие сроки осваиваь node.js но начать разрабаывать можно легко но углубиться 
// в эту технологию достаточно сложно войти легко а выйти уже сложно
// - скорость работы приложений построеных на node.js за счет не блокрующего ввода и вывода достигается максимальная скорость обработки запросов
// 1000 или 10 000 запросов в секунду
// - frontend и backend пишутся на 1 языке JS
// - богатый менеджер пакетов npm
// - быстрое протипирование создать прототип какова то продукта можно создать просто и быстро

// концепции 
// задача node.js преобразовать JS в машинный код 
// - такое преобразование достигается за счет движка V8 на катором построен node.js V8 это движок каорый разарабаывает компания google
// он также используется в браузере google chrome V8 написан на C++ его задача скомплировать и выполнить исходный код на JS
// так же он занимается выделением памяти для объектов и и занимается сборкой мусора тоесть удаляет из памяти те объекты каторые больше не нужны

// - Libuv в связке с V8 они образуют фундамент node.js и по сути являются основой
// Libuv отвечает за 2 важных момента 1 кросплатформенный input output ввод/вывод 2 цикл событий Event Loop

// - кросплатформенные операции input output к ним относятся работа с файловой системой, сетью
// для того что бы мы имели возможность установить node.js на любую операционную систему нужна некаторая оболочка програмный интерфейс
// этим и знаимается Libuv таким образом эта кросплатформенность на windows linux mac достигается средстввами Libuv


// - цикл событий Event Loop во многих языках програмирования все команды поумолчанию являются блокирующими тоесть тоесть разработчик каторый
// не позаботился об асинхронном выполнении кода заблокирует все приложение апример если надо считать файл из фаловой системы или обработать 
// сетевой запрос так вот пока этот файл не считатется с файловой системы приложение заблокируется дальше код не пойдет
// для того что бы это предотвратить спользуется многопоточное програмирование управление потоками или тредами
// параллельное рпограмирование это достаточно сложная тема
// так вот с помощью цикла событий разработка асинхронных приложений становиться гараздо проще не нужно замарачиваться над созданием физических
// потоков
// вмест того что бы на время выполнения какой либо операции заблакировать весь паток node.js продолжает заниматься другими делами до тех пор
// пока результаты выполнения этой опреаци не будут пллучены
// такие махинации происходят в цикле событий


// Асинхронная модель node.js. Сравнение блокирующего и неблокирующего ввода\вывода. Шаблон Reactor. Event loop в node js

// - классическая модель блокирующий ввод\вывод так работают классические вебсервера например на Java 
// концепция простая паток выполнения каторый строчка за строчкой выполняет какие то команды 
// пока каманды не выполнилась к следующей перейти мы не можем тоесть весь паток блакируется 
// есл команды простые никаких трудностей не возникает 
// но если инструкцим не простые например записать получить файл пработать с базой данных или с сетью при этом при блокирующей модели поведения
// весь поток блакируется приложение не способно обрабатывать другие операции для того что бы решить эту проблему такие операции
// выполняют в разных потоках тоесть на уровне операционной системы создаются патоки каторые обрабатывают разные операции
// такой подход является отличным решением но и имеет минусы
// 1 и самый важный поток потребляет большое количество ресурсов при этом зачастую есть ситуации когда поток создается но какую то часть времени
// он просто простаивает но ресурсы для этого потока уже ОС были выделены
// 2 сложность упраления этими потоками програмист каторый пишет код и пытается с ними взаимодействоваь должен обладать хорошей квалификацией
// потоки могут обращаться к одним и тем же участкам памяти возникает взаимная блокировка

// например есть некатоырй веб сервер каторый прослушивает некаорые запросы с сервером устанавливается первое соединение и для него создается
// отдельный паток внутри потока выполняется какая то операция по обработке данных и затем спутся время выполняется вторая операция
// параллельно с первым соединением устанавливается второе для него так же созадется паок с какой то обработкой данных
// и так же параллельно устанавливается 3 соединение и для него ак же выделяется новый поток
// потоки некаорое время находятся в состоянии простоя ожидая новых данных получаемых из связаных с ними соединений
// при этом потоки потребляют много ресурсов расходуют паметь и вызывают переключение контекста
// поэтому иметь дстаточно долгвыполняющийся поток для каждого подключения и при этом не использовать его длитеьную часть времени это 
// не лучшее решение с точки сзрения эффективности


// пример блокирующей и не блокирующей модели поведения 2 вебсервера apache и nginx
// apache создавал на каждое входное соединение создавал отдельный паток по блокирующей схеме


// - модель не блокирующий ввод\вывод
// например есть веб сервер из вне установлено несколько сететвых подключений сервер работает только с одним потоком так называемым
// главным потоком (Main Thread)
// при использовании не блокирующего ввод\вывод системные вызовы немеленно возвращают управление при этом не ожидая выполнения чтения или 
// записи каких либо данных
// подобный механизм доступа к ресурсам поддерживает большинство операционных систем и основным шаблоном реализации неблокирующего
// ввода и вывода является активный опрос ресурсов в цикле поскольку мало создать операцию и забыть про нее надо получить еще и результат
// ее работы
// такой паттерн называется цикл ожидания это простейший шаблон каторый определенно не является идеальным способом каторый предназначен
// для неблокрующей работы с ресурсами но в большенстве ОС есть более эффективный механизм для неблокирующий работы
// демультиплексор событий


// apache работа по блокирующей модели поведения где на каждое соединения открывался новый паток
// nginx по неблокирующйей модели ввод\вывод
// при этои при росте одновременнхы подключений количество запросов каорые мог обрабатывать apache значительно ниже чем обрабатывал nginx
// так nginx работал в 2.5 раза быстрее чем apache

// nginx - неблокирующий ввод\вывод
// Apache - классический многопоточный веб-сервер
// node.js работает по принципу неблокирующего ввод\вывод есть один главный поток и получается node.js однопоточный
// это так и не так одновреенно 
// сам по себе JS однопоточный и вся асинхронность достигается за счет Event Loop цикла событий
// сам по себе node.js однопоточный тоесть разработчики пишут асинхронный код ез использования потоков
// но при этом в основе node.js лежит Libuv каторый занимается операциями ввод\вывод
// в своей основе Libuv может управлять потоками причем дефолтное их количество 4 можно изменять
// Libuv написан на C а движек V8 написан на C++
// и на C и на C++ можно писаь какие то модули для node.js тоесть некаторые бибилиотеки могут использовать потоки

// если написать 4 функции хеширования то выполняться они почти одновременно 
// если добавить 5 вызов функции то она тработает гораздо позже

// Панировщик потоков (Thread scheduler) - это часть ОС каторый отвечает за параллельное выполнение задач
// этот планировщие выделяет потоком некаорое процессорное время память стект и прчие ресурсы
// так же есть Пул потоков (Thread pool) и в нем 4 потока
// мы 5 раз пытаемся запустить криптографическую функцию 1 поток забирает выполнение 1 криптографической функции 2 2 3 3 4 4
// поумолчанию 4 потока поэтому каждый из потков взял на себя выполение 1 функции 5 осталась ожидать
// 4 функции выполнились в одно время все потоки освободились тот из потоков каторый освобдился раньше забирает на себя 5 функцию
// поэтому 5 функция выполнилась на 500 600 милисекунд позже чем первые 4

// для разработчиков на node.js он однопоточный тоесть с потоками напрямую мы не работаем
// переодичски в некаторых ситуациях работа с патоками было необходима с версией node.js 11.7.0 был введен модуль worker_threads с помощью
// него можно управлять птоками


// как работает неблокирующий ввод\вывод?
// Современные операционные системы предоставляют механизм - Демультиплексор событий
// Именно он делает неблокирующий I\O возможным

// Демультиплексор событий Шаблон REACTOR

// Демультиплексор событий предстовляет из себя некаторый интерфейс уведобления о событиях 
// его задача заключается в сбрке и постановке в очередь событий ввода и вывода каторые поступают из набора наблюдаемых ресурсов а так же 
// блокировке появления новых доступных для обработки событий

// Event Loop не менее важная часть для работы шаблона REACTOR 
// есть некатрая очередь событий и есть некаторый бесконечный цикл (Event Loop) каторый синхронно выполняет задачи из этой очереди 
// и распределяет их дальше
// очередь содержит в себе некаторые события например было отправлено какое то сообщение, закончилось ремя у таймера 
// и для каждого события устанавливается некий обработчик в node.js он представлен функцией обратного вызова колбеком

// и так есть Демультиплексор событий, некаторый бесконечный цикл (Event Loop) и очередь событий
// должно быь какое то приложение каторое будет ожидать запрос ввода и вывода в нашем случае это приложение на node.js
// запросом ввода и вывода может быть любой сетевой запрос, запрос на чтение или запись файла обращение к БД и тд.
// и после того как операция ввода и вывода была закончена ее необходимо обработать этим так же занимается приложение

// и так сейчас есть 
// - Демультиплексор событий каторый предстовляет из себя некаторый интерфейс уведобления о событиях 
// - некаторый бесконечный цикл Event Loop
// - очередь каторая содержит в себе события и их обработчики
// - приложение каторое ожидает запрос ввода и вывода и обрабатывает эти события

// последовательность взаимодействия этих компанентов в шаблоне REACTOR

// 1 приложение создает новую операцию ввода и вывода передав запрос демультиплексору событий так же приложение должно определить обработчик
// в нашем случае эо функция обртаного вызова колбек, обработчик будет вызван тогда когда операция будет завершена
// самый важный момент что отправка нового запроса для демультиплексора событий не приводит к блокировке приложения управления немедленно 
// возвращается обратно к приложению

// 2 после завршения обработки набора операция ввода и вывода Демультиплексор событий добовляет эти новые события в очередь

// 3 цикл событий (Event Loop) выполняет обход элиментов в очереди сбытий

// 4 после чего для каждого события вызывается соответсвующий обработчик тоесть функция обртаного вызова колбек каторая была указана для 
// конкретного события в приложении

// 5 этап 2 ситуации
// - 5.а обработчик каторый является частью кода приложения возвращает управления циклу событий (Event Loop) тоесть какое то событие 
// обработали и опять вернуди управление циклу событий (Event Loop), но во время выполнения этого обработчика могут запрашиваться новые
// асинхронные операции например прочитали информацию из базы данных и теперь хотим записать ее в файл это приводит к добовлению новых операций
// в Демультиплексор событий и вся эта схема повторяется поновой 

// - 5.b все возвращается к 1 этапу

// 6 после того как (Event Loop) обработал все элименты из очереди уикл вновь заблокируется демультиплексором событий и вся эта процедура 
// начнется поновой когда появится новый запрос на операцию ввода и вывода 



// каждая ОС имеет свой интерфейс для демультиплексора событий
// у Linux это epoll
// у windows это I/O Completion Port (IOCP)
// у Mac OS это kqueue
// поскольку в каждой ОС интерфейсы разные и например в Linux обычные файлы неподдерживают неблокирующих операций 
// поэтому для иметации неблокирующей модели поведения необходимо использовать отдельный поток в не цикла событий 
// тоесть нужна некаторая абстракция каторая для всех ОС будет делать неблокирующую модель поведения одинаковой и предсказуемой
// поэтому разработчики ядра платформы node.js разработали библиотеку на С Libuv
// за счет нее и обеспечивается совмстимость node.js с всеми основными платформами
// библиотека Libuv реализует шаблон REACTOR и обеспечивает програмный интерфейс для создания циклов событий, упрвления очередью событий 
// выполнения асинхронных операций ввода и вывода и организации очереди задач разных типов


// Event Loop в node.js
// когда node.js запускается она инициализирует некаторый цикл событий (Event Loop) 
// node.js обрабатывает предоставленый на вход код каторый может выполнять вызов асинхронного API нстраивать какие то различные таймеры и тд.
// после чего начинается обработка цикла событий 
// порядк выплнения операций в цикле событий 
// фазы цикла событий каждая из этих фаз имеет очередь колбеков для выполнения 
// когда цикл событий входит в фазу он будет выполнять любые операции относящиеся к этой фазу затем он будет выполнять колбеки из очереди
// после того как он выполнит все колбеки он переходит на следующую фазу и выполняет там колбеки

// - Таймеры: в этой фазе выполняются колбеки катрые запланированы 2 функциями setTimeout setInterval
// - I\O Коллбеки: Коллбеки ввода и вывода сдесь выполняются почти все колбеки за исключением событий close, Таймеров и сбытий каторый были
// определены с помощью функции setImmediate в node.js
// - Ождиание, подготовка: эта фаза используется только для внутренних целей
// - Опрос: в этой фазе происходит получение новых событий ввода и вывода при это node.js может блокировать на этом этапе
// - Проверка: на этом этапе вызываются те колбеки каторые были определены с помощью функции setImmediate
// - Коллбеки "close": на этом этапе вызываются колбеки события "close" например закрытия WebSocket соединения, закрытия стрима считывающего
// какие то данные 

// цикл проходит все фазы выполняет колбеки из очереди и запускается поновой 


// асинхронность 2 модели блокирующая не блокирующая, многопоточность, шаблон REACTOR, Event Loop в node.js